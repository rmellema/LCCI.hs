-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Package used for evaluating statements in LCCI models
--   
--   Please see the README on Github at
--   <a>https://github.com/rmellema/LCCI.hs#readme</a>
@package LCCI
@version 0.1.0.0


-- | This Module exports some utility functions that are in use in other
--   parts of the project.
module LCCI.Util

-- | Given a list of lists, calculate all the possible permutations of
--   their elements. So it picks one element for each list, and then puts
--   that in front of the permutations of the rest of the lists. This is
--   the same as making a list comprehension that takes from each list, but
--   for an unknown number of lists.
permutate :: [[a]] -> [[a]]

-- | Show a list of objects with parenthesis around it. The first argument
--   is the string that is shown in between the elements of the list
prettyShowWithParen :: PrettyShow a => String -> [a] -> String

-- | A class for objects that can be shown in a "pretty" way, instead of
--   just in a way that Haskell can read in.
class PrettyShow a

-- | Show an object in a more human-readable manner
prettyShow :: PrettyShow a => a -> String

-- | Same as <a>print</a>, but using <a>prettyShow</a> instead of
--   <a>show</a>.
prettyPrint :: PrettyShow a => a -> IO ()

-- | Take from a list until a certain predicate <tt>p</tt> holds. This
--   includes the first element for which the predicate holds.
takeUntil :: (a -> Bool) -> [a] -> [a]

-- | Calculate the matching starts for a list of lists, and return the
--   mathing start together with the non-matching ends of the lists.
match :: Eq a => [[a]] -> ([a], [[a]])
instance LCCI.Util.PrettyShow GHC.Types.Bool
instance (LCCI.Util.PrettyShow a, LCCI.Util.PrettyShow b) => LCCI.Util.PrettyShow (a, b)
instance LCCI.Util.PrettyShow a => LCCI.Util.PrettyShow [a]
instance LCCI.Util.PrettyShow a => LCCI.Util.PrettyShow (Data.Set.Internal.Set a)
instance (LCCI.Util.PrettyShow a, LCCI.Util.PrettyShow b) => LCCI.Util.PrettyShow (Data.Map.Internal.Map a b)


-- | This module implements the Syntax of LCCI, and formulas for
--   manipulating this syntax.
module LCCI.Syntax

-- | An atomic program with no internal structure
data Atomic

-- | Create a new atom from a string. The first letter will be lowercased
atom :: String -> Atomic

-- | A full program
data Program
Atom :: Atomic -> Program
Test :: Formula -> Program
Sequence :: [Program] -> Program
Choice :: [Program] -> Program
Iterate :: Program -> Program

-- | A Logical Proposition
data Proposition

-- | Create a new Proposition from a string. The first letter will be
--   uppercased
proposition :: String -> Proposition

-- | A Formula in LCCI
data Formula
Prop :: Proposition -> Formula
Bot :: Formula
Top :: Formula
Neg :: Formula -> Formula
Quest :: Formula -> Formula
And :: [Formula] -> Formula
Or :: [Formula] -> Formula
IOr :: [Formula] -> Formula
Cond :: Formula -> Formula -> Formula
BiCond :: Formula -> Formula -> Formula
Modal :: Program -> Formula -> Formula
IModal :: Program -> Formula -> Formula
Update :: (String, UpdateModel) -> [Event] -> Formula -> Formula

-- | A datatype for structures that can be flattened, like programs and
--   formulas
class (Eq a) => FlattenAble a

-- | Flatten a given structure by one step in the process.
flattenStep :: FlattenAble a => a -> a

-- | Fully flatten the given structure.
flatten :: FlattenAble a => a -> a

-- | A datatype for structures that can be flattenend an simplified, like
--   programs and formulas.
class (FlattenAble a) => Simplify a

-- | Simplify the given structure by one step in the simplification process
simplifyStep :: Simplify a => a -> a

-- | Fully simplify the given structure.
simplify :: Simplify a => a -> a

-- | Expand the outer part of a formula by replacing the abbreviations.
--   Also folds together conjunctions inside conjunctions etc.
expandStep :: Formula -> Formula

-- | Expand a formula by replacing all of the abbreviations in them.
expand :: Formula -> Formula

-- | Check if a given formula is declarative
isDeclarative :: Formula -> Bool

-- | Give the resolutions of a given formula for models with at most
--   <a>Int</a> worlds.
resolutions :: Int -> Formula -> [Formula]
instance GHC.Show.Show LCCI.Syntax.Program
instance GHC.Classes.Eq LCCI.Syntax.Program
instance GHC.Show.Show LCCI.Syntax.Formula
instance GHC.Classes.Eq LCCI.Syntax.Formula
instance GHC.Show.Show LCCI.Syntax.Proposition
instance GHC.Classes.Eq LCCI.Syntax.Proposition
instance GHC.Classes.Ord LCCI.Syntax.Proposition
instance GHC.Show.Show LCCI.Syntax.Atomic
instance GHC.Classes.Eq LCCI.Syntax.Atomic
instance GHC.Classes.Ord LCCI.Syntax.Atomic
instance LCCI.Util.PrettyShow LCCI.Syntax.Program
instance LCCI.Syntax.FlattenAble LCCI.Syntax.Program
instance LCCI.Syntax.Simplify LCCI.Syntax.Program
instance LCCI.Util.PrettyShow LCCI.Syntax.Formula
instance LCCI.Syntax.FlattenAble LCCI.Syntax.Formula
instance LCCI.Syntax.Simplify LCCI.Syntax.Formula
instance LCCI.Util.PrettyShow LCCI.Syntax.Proposition
instance LCCI.Util.PrettyShow LCCI.Syntax.Atomic


-- | A module that defines the substitutions for LCCI and functions for
--   working with them. A substitution is a map from propositional atoms to
--   formulas, that can be used to change the truth value of a proposition
--   after the execution of an action.
module LCCI.Substitution

-- | A type for the substitutions.
data Substitution

-- | Test to see if a substitution is empty
null :: Substitution -> Bool

-- | Calculate the size of a given substitution, i.e. how many propositions
--   it maps to other formulas.
size :: Substitution -> Int

-- | The empty substitution.
empty :: Substitution

-- | Insert a new mapping into a substitution.
insert :: Proposition -> Formula -> Substitution -> Substitution

-- | Create a substitution from a list of mappings.
fromList :: [(Proposition, Formula)] -> Substitution

-- | Transform the given substitution into a list of mappings.
toList :: Substitution -> [(Proposition, Formula)]

-- | The domain of this substitution.
domain :: Substitution -> [Proposition]

-- | Lookup a given proposition in the substitution. Returns <a>Nothing</a>
--   if the proposition is not mapped to anything else.
lookup :: Proposition -> Substitution -> Maybe Formula

-- | Apply the proposition to the substitution. The same as <a>lookup</a>,
--   but returns the proposition in case it is not mapped to anything.
apply :: Substitution -> Formula -> Formula

-- | Lookup the given proposition in the substitution. Returns the
--   proposition as a formula in case it is not mapped to anything.
(!) :: Substitution -> Proposition -> Formula
infixl 9 !
instance GHC.Show.Show LCCI.Substitution.Substitution
instance GHC.Classes.Eq LCCI.Substitution.Substitution
instance LCCI.Util.PrettyShow LCCI.Substitution.Substitution


-- | This module implements the structures from Inquisitive Semantics
--   Information States, Issues, and State Maps.
module LCCI.Issue

-- | A world in an LCCI model
class (Ord a) => World a

-- | An information state
type State a = Set a

-- | A convience function for defining States. Creates a state with every
--   world in the input list
state :: Ord a => [a] -> State a

-- | A new issue. This will not garantee that an Issue is downward closed.
type Issue a = Set (Set a)

-- | A prettier way to show Issues
showIssue :: (PrettyShow a, Ord a) => Issue a -> String

-- | Creates an empty issue, i.e. an issue that only contains the empty
--   state
emptyIssue :: Issue a

-- | Create an issue from a list of information states
issue :: Ord a => [Set a] -> Issue a

-- | Create the powerset of a given set.
powerset :: Ord a => Set a -> Set (Set a)

-- | Calculate the downward closure of a set of sets.
downwardClose :: Ord a => Set (Set a) -> Set (Set a)

-- | Check to see if an issue is downward closed
isDownwardClosed :: Ord a => Issue a -> Bool

-- | Find the alternatives in an issue
alternatives :: Ord a => Issue a -> [Set a]

-- | A statemap for orderable objects
type StateMap a = Map a (Issue a)

-- | Turn a statemap into a human readable string. The entries in the
--   statemap are spereated by the string given in <tt>i</tt>.
showStateMap :: (Ord a, PrettyShow a) => String -> String -> StateMap a -> String

-- | Turn a map of statemaps into a human readable string. The elements in
--   the statemap and between statemaps are seperated by the string
--   <tt>i</tt>.
showStateMaps :: (Ord a, PrettyShow a, PrettyShow b) => String -> Map b (StateMap a) -> String


-- | <ul>
--   <li>This module implements a simple model of Relations between
--   information states.</li>
--   </ul>
module LCCI.Relation

-- | The relation type, used for relating information states to other
--   relation states.
data Relation a

-- | Check if a given relation is empty.
null :: Relation a -> Bool

-- | The empty relation, i.e., the relation that maps nothing to something
--   else.
empty :: Relation a

-- | Add a relation between two information states.
insert :: Ord a => Relation a -> State a -> State a -> Relation a

-- | Read a relation from a list of tuples.
fromList :: Ord a => [(State a, State a)] -> Relation a

-- | Read a relation from a given state map
fromStateMap :: World a => StateMap a -> Relation a

-- | Get all the information states that this relation relates to others.
keys :: Relation a -> [State a]

-- | Turn this relation into a list of tuples
toList :: Relation a -> [(State a, State a)]

-- | Take the union of two relations.
union :: Ord a => Relation a -> Relation a -> Relation a

-- | Compose two relations together
compose :: Ord a => Relation a -> Relation a -> Relation a

-- | Take the reflexive closure of this relation.
reflexiveClosure :: Ord a => Relation a -> Relation a

-- | Take the transitiveClosure of this relation.
transitiveClosure :: Ord a => Relation a -> Relation a

-- | Map the given function <tt>f</tt> over the domain of the relation.
mapDomain :: Ord b => (State a -> b) -> Relation a -> [b]

-- | Lookup to which states this relation relates a given information
--   state. Returns an empty set if it maps it to none.
lookup :: Ord a => Relation a -> State a -> Set (State a)

-- | Check if the given relation adheres to all the properties that an
--   IE-PDL relation should.
isValid :: Ord a => Relation a -> Bool

-- | Make all the keys for a given relation.
makeKeys :: Ord a => Relation a -> Relation a

-- | Make sure that the given relation adheres to all the properties it has
--   to.
makeValid :: Ord a => Relation a -> Relation a

-- | Turn the given map of <tt>Relation</tt>s into a string.
showRelation :: (PrettyShow a, Ord a) => Map Atomic (Relation a) -> String
instance GHC.Show.Show a => GHC.Show.Show (LCCI.Relation.Relation a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (LCCI.Relation.Relation a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (LCCI.Relation.Relation a)
instance (LCCI.Util.PrettyShow a, GHC.Classes.Ord a) => LCCI.Util.PrettyShow (LCCI.Relation.Relation a)


-- | This module implements both the static and update models of LCCI,
--   including the Valuation
module LCCI.Model

-- | The valuation for an IE-PDL model.
type Valuation a = (Proposition -> a -> Bool)

-- | A simple way to define a Valuation, by specifing which propositions
--   are true in a world.
type ValuationMap a = Map a (Set Proposition)

-- | Turn the given <tt>ValuationMap</tt> into a string.
showValuationMap :: Show a => String -> ValuationMap a -> String

-- | A <tt>StaticModel</tt> represents an IE-PDL model.
data StaticModel a
StaticModel :: Set a -> Valuation a -> Map Atomic (StateMap a) -> StaticModel a

-- | The worlds in this model.
[worlds] :: StaticModel a -> Set a

-- | The valuation for this model. Should be a full function over
--   <tt>worlds</tt>
[valuation] :: StaticModel a -> Valuation a

-- | The statemap belonging to the model. Should relate every world in
--   <tt>worlds</tt> to some information state.
[staticStatemap] :: StaticModel a -> Map Atomic (StateMap a)

-- | A type to represent events in the <tt>UpdateModel</tt>.
newtype Event
Event :: Int -> Event

-- | A type to represent an LCCI model, used to be combined with a
--   <tt>StaticModel</tt> to evaluate <tt>Formula</tt>s with an update
--   operator.
data UpdateModel
UpdateModel :: Set Event -> Map Atomic (StateMap Event) -> Map Event Formula -> Map Event Substitution -> UpdateModel
[events] :: UpdateModel -> Set Event
[eventStatemap] :: UpdateModel -> Map Atomic (StateMap Event)
[precondition] :: UpdateModel -> Map Event Formula
[substitutions] :: UpdateModel -> Map Event Substitution
instance GHC.Show.Show LCCI.Model.UpdateModel
instance GHC.Classes.Eq LCCI.Model.UpdateModel
instance GHC.Show.Show LCCI.Model.Event
instance GHC.Classes.Eq LCCI.Model.Event
instance GHC.Classes.Ord LCCI.Model.Event
instance LCCI.Util.PrettyShow LCCI.Model.UpdateModel
instance LCCI.Util.PrettyShow LCCI.Model.Event
instance GHC.Show.Show a => GHC.Show.Show (LCCI.Model.StaticModel a)
instance (LCCI.Issue.World a, LCCI.Util.PrettyShow a) => LCCI.Util.PrettyShow (LCCI.Model.StaticModel a)
instance (LCCI.Issue.World a, GHC.Classes.Ord b) => LCCI.Issue.World (a, b)


-- | This module allows for the reduction of formulas to equivalent
--   formulas that - do not use the Update operator.
module LCCI.Reduce

-- | Reduce a given LCCI formula to its IE-PDL equivalent
reduce :: Int -> Formula -> Formula

-- | Set the next step of the reduction from LCCI to IE-PDL
reduceStep :: Int -> Formula -> Formula
tr :: UpdateModel -> Set Event -> Set Event -> Program -> Program
k :: UpdateModel -> Set Event -> Set Event -> Set Event -> Program -> Program


-- | This module holds the code for the evaluation of LCCI formulas in
--   models.
module LCCI.Evaluation

-- | Calculate all the states that are related to a given state by a
--   program in the given model.
compoundRelation :: World a => StaticModel a -> Program -> State a -> Set (State a)

-- | Calculate the compound relation for a given model and program.
compoundRelation' :: World a => StaticModel a -> Program -> Relation a

-- | Check if the given formula is supported in the model and state.
supports :: World a => StaticModel a -> State a -> Formula -> Bool

-- | Update the given <tt>StaticModel m</tt> with the given <tt>UpdateModel
--   u</tt>.
productUpdate :: World a => StaticModel a -> UpdateModel -> StaticModel (a, Event)

-- | Calculate the updated state of <tt>s</tt> in <tt>m</tt> under
--   application of events <tt>es</tt> from model <tt>u</tt>.
updatedState :: World a => StaticModel a -> State a -> UpdateModel -> [Event] -> State (a, Event)


-- | <ul>
--   <li>A module for making the reading and writing of formulas easier, by
--   defining</li>
--   <li>operators and functions that are less efficient, but eaier to
--   use.</li>
--   </ul>
module LCCI.Syntax.Pretty

-- | A class for objects that can be shown in a "pretty" way, instead of
--   just in a way that Haskell can read in.
class PrettyShow a

-- | Show an object in a more human-readable manner
prettyShow :: PrettyShow a => a -> String

-- | A class fo objects that can be cast into Formulas
class FormulaLike a

-- | Cast an object into a formula
asFormula :: FormulaLike a => a -> Formula

-- | A class for objects that can be cast into programs.
class ProgramLike a

-- | Cast an object into a program
asProgram :: ProgramLike a => a -> Program

-- | Create a test program for a given formula
test :: FormulaLike a => a -> Program

-- | The sequence operator for programs
(.>) :: (ProgramLike a, ProgramLike b) => a -> b -> Program
infixl 5 .>

-- | The power operator for programs
(.^) :: ProgramLike a => a -> Int -> Program
infix 4 .^

-- | The choice operators for programs
(.+) :: (ProgramLike a, ProgramLike b) => a -> b -> Program
infixl 5 .+

-- | Create the iterate program of a given program
iter :: ProgramLike a => a -> Program

-- | Create a polar question for a given formula
polar :: FormulaLike a => a -> Formula

-- | Give the negation of a given formula
neg :: FormulaLike a => a -> Formula

-- | The conjunction operator for formulas
(/\) :: (FormulaLike a, FormulaLike b) => a -> b -> Formula
infixl 5 /\

-- | The disjunction operator for formulas
(\/) :: (FormulaLike a, FormulaLike b) => a -> b -> Formula
infixl 5 \/

-- | The inquisitive disjunction operator for formulas
(\\/) :: (FormulaLike a, FormulaLike b) => a -> b -> Formula
infixl 5 \\/

-- | The implication operator
(-->) :: (FormulaLike a, FormulaLike b) => a -> b -> Formula
infix 6 -->

-- | Biimplication operator
(<->) :: (FormulaLike a, FormulaLike b) => a -> b -> Formula
infix 6 <->

-- | The normal modality
knows :: (ProgramLike a, FormulaLike b) => a -> b -> Formula

-- | The inquisitive modality
entertains :: (ProgramLike a, FormulaLike b) => a -> b -> Formula

-- | A function to quickly make the wonder modality
wonder :: (ProgramLike a, FormulaLike b) => a -> b -> Formula

-- | The update procedure operator
(@@) :: World a => StaticModel a -> UpdateModel -> StaticModel (a, Event)
infix 1 @@

-- | The updated state operator
(.@) :: World a => (StaticModel a, State a) -> (UpdateModel, [Event]) -> State (a, Event)
infix 1 .@

-- | Supports operator
(|=) :: World a => (StaticModel a, State a) -> Formula -> Bool
infix 9 |=
instance LCCI.Syntax.Pretty.FormulaLike LCCI.Syntax.Formula
instance LCCI.Syntax.Pretty.FormulaLike LCCI.Syntax.Proposition
instance LCCI.Syntax.Pretty.FormulaLike GHC.Types.Bool
instance LCCI.Syntax.Pretty.ProgramLike LCCI.Syntax.Program
instance LCCI.Syntax.Pretty.ProgramLike LCCI.Syntax.Atomic


-- | A module that holds examples for update models for different
--   communication - types
module LCCI.Announcements
p :: Proposition
q :: Proposition
r :: Proposition
ingroup :: Atomic
outgroup :: Atomic

-- | An infinite list with events, which is useful for zipping with or
--   taking from. Numbering of this list starts at 1.
eventList :: [Event]
prtStr :: String -> Bool -> [Formula] -> String

-- | Create an issue where the agent entertains which specific event
--   occured
worldIssue :: Ord a => [a] -> Issue a

-- | A function that create an update model for the public announcement of
--   a question. Can be used for the public announcement of a declarative
--   if only one formula is given. The formula will not check if the
--   formulas given are actually declarative. The <a>String</a> is used as
--   the name for the update model, and will be substituted by a default if
--   left empty.
publicRaise :: String -> [Atomic] -> [Formula] -> (String, UpdateModel)

-- | A function that creates an update model for the public announcement of
--   a given formula. The <a>Int</a> is for the maximum size of the model
--   in which the formula will be announced, and can be ignored if the
--   formula is declarative. It is used to calculate the resolutions of the
--   formula. See <a>publicRaise</a> for more control over the asking of
--   questions.
public :: [Atomic] -> Formula -> Int -> (String, UpdateModel)

-- | A convience function for calling <a>publicRaise</a> without having to
--   supply a string. Will always revert to the default.
defaultPublicRaise :: [Atomic] -> [Formula] -> (String, UpdateModel)

-- | Create an update model for the private announcement of a question. In
--   this case, all the agents are aware that a question is being asked,
--   but they are not all aware what this question is. This question is the
--   inquisitive disjunction of the given list of formulas. The first list
--   of <a>Atomic</a> agents are the ingroup, the group that knows which
--   question is asked. The second are the outgroup, the group that does
--   not know which question is asked, but wants to know, and the third are
--   the agents that do not care about the question being asked. The rest
--   of the parameters are as in <a>publicRaise</a>.
privateRaise :: String -> [Atomic] -> [Atomic] -> [Atomic] -> [Formula] -> (String, UpdateModel)

-- | Create an update model for the private announcement of some formula.
--   In this case, all the agents are aware that some piece of information
--   is given, but they are not all aware what this is. The first list of
--   <a>Atomic</a> agents are the ingroup, the group that knows what is
--   being told. The second are the outgroup, the group that does not know
--   what is being told, but wants to know, and the third are the agents
--   that do not care about the information. The list of formulas are all
--   the possible pieces of information that can be shared. If this list
--   has a length of 1, an extra event with precondition True will be added
--   to the model. The rest of the parameters are as in <a>publicRaise</a>.
privateInform :: String -> [Atomic] -> [Atomic] -> [Atomic] -> [Formula] -> (String, UpdateModel)

-- | A function that creates an update model for the private announcement
--   of a given formula, where the rest of the group knows that some
--   formula is annouced. See <a>privateRaise</a> for explanations on the
--   groups, and <a>public</a> for an explanation of the <a>Formula</a> and
--   <a>Int</a>
private :: [Atomic] -> [Atomic] -> [Atomic] -> Formula -> Int -> (String, UpdateModel)

-- | Create an update model for the secret announcement of a question. In
--   this case, only a subset of the agents (the first parameter) are aware
--   that a question is being asked, while the rest of the agents are not
--   even aware that something is happening. the rest of the parameters are
--   as in <a>publicRaise</a>.
secretRaise :: String -> [Atomic] -> [Atomic] -> [Formula] -> (String, UpdateModel)

-- | A function that creates an update model for the secret announcement of
--   a given formula, where the rest of the group is not aware that an
--   announcement has been made. See <a>secretRaise</a> for a description
--   of the first two parameters, and <a>public</a> for the description of
--   the second two.
secret :: [Atomic] -> [Atomic] -> Formula -> Int -> (String, UpdateModel)

module LCCI.Examples.Hexa

-- | The worlds in the Hex model
w012 :: (Int, Int, Int)

-- | The worlds in the Hex model
w021 :: (Int, Int, Int)

-- | The worlds in the Hex model
w102 :: (Int, Int, Int)

-- | The worlds in the Hex model
w120 :: (Int, Int, Int)

-- | The worlds in the Hex model
w201 :: (Int, Int, Int)

-- | The worlds in the Hex model
w210 :: (Int, Int, Int)

-- | The set of worlds
ws :: Set (Int, Int, Int)

-- | The propositions in the Hex model
a0 :: Proposition

-- | The propositions in the Hex model
a1 :: Proposition

-- | The propositions in the Hex model
a2 :: Proposition

-- | The propositions in the Hex model
b0 :: Proposition

-- | The propositions in the Hex model
b1 :: Proposition

-- | The propositions in the Hex model
b2 :: Proposition

-- | The propositions in the Hex model
c0 :: Proposition

-- | The propositions in the Hex model
c1 :: Proposition

-- | The propositions in the Hex model
c2 :: Proposition

-- | Get the number of the card for the given proposition.
card :: Proposition -> String

-- | Get the identifier for the player in the given proposition.
player :: Proposition -> Char

-- | The valuation of the propositional atoms
v :: Valuation (Int, Int, Int)

-- | The "actions" in the Hex model (The knowledge relations)
a :: Atomic

-- | The "actions" in the Hex model (The knowledge relations)
b :: Atomic

-- | The "actions" in the Hex model (The knowledge relations)
c :: Atomic
ann_map :: StateMap (Int, Int, Int)

-- | The state maps for all the various agents.
s :: Map Atomic (StateMap (Int, Int, Int))

-- | The actual model
hexa :: StaticModel (Int, Int, Int)
ann_look :: (String, UpdateModel)
ann_events :: [Event]
hexa1 :: StaticModel ((Int, Int, Int), Event)
ws1 :: Set ((Int, Int, Int), Event)
hexa2 :: StaticModel (((Int, Int, Int), Event), Event)
ws2 :: Set (((Int, Int, Int), Event), Event)
hexa3 :: StaticModel ((((Int, Int, Int), Event), Event), Event)
ws3 :: Set ((((Int, Int, Int), Event), Event), Event)
e1 :: Event
e2 :: Event
e3 :: Event
ei :: StateMap Event
em :: Map Atomic (StateMap Event)
pre :: Map Event Formula
sub :: Map Event Substitution
swap_bill_carol :: UpdateModel
swap_events :: [Event]
swap_bill_carol' :: (String, UpdateModel)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, GHC.Classes.Ord c) => LCCI.Issue.World (a, b, c)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => LCCI.Util.PrettyShow (a, b, c)


-- | A module that holds classes and functions for transforming a given
--   datastructure into its (La)TeX representation. This module assumes
--   things will be printed in mathmode, unless specifically mentioned
--   otherwise or enabled by the resulting LaTeX code itself. It will also
--   assume the excistens of the following LaTeX macros:
--   
--   <ul>
--   <li><i><tt>\lnot</tt></i> Logical negation</li>
--   <li><i><tt>\land</tt></i> Logical conjunction</li>
--   <li><i><tt>\lor</tt></i> Logical disjunction</li>
--   <li><i><tt>\lior</tt></i> Inquisitive disjunction</li>
--   <li><i><tt>\lif</tt></i> Material conditional</li>
--   <li><i><tt>\liff</tt></i> Biimplication</li>
--   <li><i><tt>\lac</tt></i> Typesets the modal program operator. Takes
--   one argument, which is the program that goes into the modal
--   operator.</li>
--   <li><i><tt>\liac</tt></i> Typesets the inquisitive modal program
--   operator. Takes one argument, which is the program that goes into the
--   modal operator.</li>
--   <li><i><tt>\lup</tt></i> Typesets the update operator. Takes an
--   optional argument (the name of the update model) and a required one
--   (the (set of) events that is being executed.</li>
--   <li><i><tt>\upd</tt></i> Typesets in the font used for update model
--   symbols. Takes one argument, the thing to be typeset in that
--   font.</li>
--   <li><i><tt>\pre</tt></i> Typesets the function for the precondition.
--   Takes one argument, the thing upon which the function is called.</li>
--   <li><i><tt>\sub</tt></i> Typesets the function for the substitution.
--   Takes one argument, the thing upon which the function is called.</li>
--   </ul>
module LCCI.Util.Tex

-- | Convert a datastructure to a valid TeX representation of the
--   structure. May use the commands given at the start of this module.
class Texable a

-- | Create a TeX representation of the given object, prepended with the
--   given string on each line, put in braces.
texWithParen :: Texable a => String -> a -> String

-- | Create a TeX representation of the given object, prepend with the
--   given string on each line
texPrepend :: Texable a => String -> a -> String

-- | Create a TeX representation of the given subject, if needed within
--   brackets
toTexWithParen :: Texable a => a -> String

-- | Create a TeX representation of a given object
toTex :: Texable a => a -> String

-- | Enclose the TeX representation of the list with the first and second
--   argument, separated by the third. Useful for making lists and sets.
enclose :: Texable a => String -> String -> String -> [a] -> String

-- | Get the TeX representation enclosed in parenthesis. The first argument
--   is the separator for in between the elements.
withParens :: Texable a => String -> [a] -> String
asSet :: Texable a => [a] -> String
instance LCCI.Util.Tex.Texable LCCI.Syntax.Program
instance LCCI.Util.Tex.Texable LCCI.Syntax.Formula
instance LCCI.Util.Tex.Texable LCCI.Model.Event
